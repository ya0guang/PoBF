extern crate aes;
extern crate base64;
extern crate clap;
extern crate cmac;
extern crate curl;
extern crate ring;
extern crate serde_json;

mod dh;
mod handlers;
mod utils;

use clap::{Parser, Subcommand};
use dh::*;
use handlers::*;

use std::io::*;

#[derive(Parser)]
#[clap(author, version, about, long_about = None)]
#[clap(propagate_version = true)]
struct Args {
    #[clap(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    Run {
        address: String,
        port: u16,
        spid: String,
        key: String,
        // Whether this subscription allows multiple requests from one platform.
        linkable: bool,
    },
}

// Configurations for the IAS.
static IAS_BASE_URL: &'static str = "https://api.trustedservices.intel.com";
// Use the newest APIs. (v3 is decprecated.)
static IAS_BASE_REQUEST: &'static str = "/sgx/dev/attestation/v4/";
static IAS_KEY_HEADER: &'static str = "Ocp-Apim-Subscription-Key";
static IAS_CONTENT_TYPE_HEADER: &'static str = "Content-Type";
static IAS_XIAS_SIGNCERT_HEADER: &'static str = "X-IASReport-Signing-Certificate";
static IAS_XIAS_SIG_HEADER: &'static str = "X-IASReport-Signature";
static IAS_QUOTE_TIMESTAMP: &'static str = "\"timestamp\"";
static ISV_ENCLAVE_QUOTE_STATUS: &'static str = "\"isvEnclaveQuoteStatus\"";
static PLATFORM_INFO_BLOB: &'static str = "\"platformInfoBlob\"";
static ISV_ENCLAVE_QUOTE_BODY: &'static str = "\"isvEnclaveQuoteBody\"";

/// This is hardcoded into the program. Can be easily generated by OpenSSL.
/// Command is
/// ```shell
///   $ openssl ecparam -name prime256v1 -genkey > /tmp/ecprivkey.pem \
///   $ openssl ec -in /tmp/ecprivkey.pem -text -noout
///     read EC key
///     using curve name prime256v1 instead of secp256r1
///     Private-Key: (256 bit)
///     [key details]
///     ASN1 OID: prime256v1
///     NIST CURVE: P-256
/// ```
/// TODO: Maybe we need to sign the public key using ECDSA.
const SP_PRIVITE_KEY: &'static [u8; 32] = &[
    0x70, 0x38, 0xae, 0xa2, 0x78, 0x0d, 0xd5, 0x15, 0x5b, 0x52, 0x08, 0xe1, 0xa1, 0x8d, 0x83, 0x95,
    0x91, 0x4b, 0x6e, 0xbc, 0xb1, 0x6a, 0x58, 0xb5, 0xad, 0x88, 0x39, 0x14, 0x74, 0x7d, 0xc5, 0xeb,
];


fn main() {
    // Generate key pair.
    let (private_key, public_key) = open_session().unwrap();
    println!("[+] Key pair: {:?} and {:?}", private_key, public_key);

    let args = Args::parse();
    match args.command {
        Commands::Run {
            address,
            port,
            spid,
            key,
            linkable,
        } => {
            let socket = connect(&address, &port).expect("[-] Cannot connect to the given address");
            let socket_clone = socket.try_clone().unwrap();
            let mut reader = BufReader::new(socket);
            let mut writer = BufWriter::new(socket_clone);

            // Send Spid and public key to the application enclave.
            send_spid(&mut writer, &spid, linkable, &public_key).unwrap();

            let sigrl =
                handle_epid(&mut reader, &mut writer, &key).expect("[-] EPID receiving failed.");
            let enclave_pubkey = handle_enclave_pubkey(&mut reader).unwrap();
            println!("[+] The public key of the enclave is {:?}", enclave_pubkey);

            send_sigrl(&mut writer, sigrl).unwrap();

            // Handle quote.
            handle_quote(&mut reader, &mut writer, &key).unwrap();

            // Compute shared key.
            let session_key =
                compute_shared_key(private_key, &enclave_pubkey, KDF_MAGIC_STR.as_bytes()).unwrap();

            println!("[+] The session key sampled as {:?}", session_key);

            // Quit.
            writer.write(b"q\n").unwrap();
        }
    }

    println!("[+] Finished!");
}
