#![allow(unused)]
#![forbid(unsafe_code)]

use alloc::string::String;
use alloc::vec::Vec;

use mirai_annotations::*;
use sgx_crypto::ecc::*;
use sgx_types::{
    error::{SgxResult, SgxStatus},
    types::{AlignKey128bit, DhSessionRole, Ec256PublicKey, ECP256_KEY_SIZE},
};

use crate::{log, networking_utils::unix_time, ocall_log, verified_log};

cfg_if::cfg_if! {
  if #[cfg(mirai)] {
      use crate::mirai_types::mirai_comp::SecretTaint;
  } else {
      type SecretTaint = ();
  }
}

/// Time for expiration. We currently set it to 600 seconds (10 min).
/// If the key is expired, the both sides are notified and then re-negotiate a new one.
pub const DH_KEY_EXPIRATION: u64 = 600;

/// Size for the ECC public key coordinate.
pub const ECP_COORDINATE_SIZE: usize = 64;

/// A magic string that identifies the key.
pub const KDF_MAGIC_STR: &'static str = "PoBF/enclave&session-key";

/// Used to verify the signature of the public key. Hardcoded into the enclave.
/// Can be easily generated by OpenSSL.
/// Command is
/// ```shell
///   $ openssl ecparam -name prime256v1 -genkey > /tmp/ecprivkey.pem \
///   $ openssl ec -in /tmp/ecprivkey.pem -text -noout
///     read EC key
///     using curve name prime256v1 instead of secp256r1
///     Private-Key: (256 bit)
///     [key details]
///     ASN1 OID: prime256v1
///     NIST CURVE: P-256
///   $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt \
///     -in ecprivkey.pem -out ecprivpkcs8.pem # Convert to pkcs#8 format.
/// ```
/// This certificate is self-signed and used only in development environment.
/// It is a must that the SP obtains a Root CA-signed (e.g. DigiCert, GeoTrust) certificate.
pub const SP_CERT: &'static str = "-----BEGIN CERTIFICATE-----
MIICbzCCAhWgAwIBAgIUYoPMHkOlEJHtlnvTIKDV/Ladp5gwCgYIKoZIzj0EAwIw
gYwxCzAJBgNVBAYTAlVTMRAwDgYDVQQIDAdJbmRpYW5hMRQwEgYDVQQHDAtCbG9v
bWluZ3RvbjEbMBkGA1UECgwSSW5kaWFuYSBVbml2ZXJzaXR5MSQwIgYDVQQLDBtM
dWRkeSBTY2hvb2wgb2YgSW5mb3JtYXRpY3MxEjAQBgNVBAMMCTEyNy4wLjAuMTAe
Fw0yMjEwMjEwMjUyMTNaFw0zMjEwMTgwMjUyMTNaMIGMMQswCQYDVQQGEwJVUzEQ
MA4GA1UECAwHSW5kaWFuYTEUMBIGA1UEBwwLQmxvb21pbmd0b24xGzAZBgNVBAoM
EkluZGlhbmEgVW5pdmVyc2l0eTEkMCIGA1UECwwbTHVkZHkgU2Nob29sIG9mIElu
Zm9ybWF0aWNzMRIwEAYDVQQDDAkxMjcuMC4wLjEwWTATBgcqhkjOPQIBBggqhkjO
PQMBBwNCAAQgaU4UnfRFlhxKBDT1AqWENEFR4AV6WpzZ7L6lV7tGTxdcxi1PNNXe
8hQXG6cj8gcCyYhy4DrgvduaWeqTnqZeo1MwUTAdBgNVHQ4EFgQUdF6of7qm511v
tvMfbMWOe1jv7QEwHwYDVR0jBBgwFoAUdF6of7qm511vtvMfbMWOe1jv7QEwDwYD
VR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAgNIADBFAiA+zu0DCqma/pnpgEhx+oAy
yGOxdFLHoZoAyN4ec4W+awIhAJfzb181oFh3G3qQT//VMv3AxwIU5hy0rmoNb9LS
5jem
-----END CERTIFICATE-----";

/// A wrapper class for an empheral Diffie-Hellman session with the client.
/// Owned by the receiver. The key is define on the curve NIST P-256 a.k.a.
/// secp256r1, prime256v1.
#[derive(Debug)]
pub struct DhEccContext {
    ecc_handle: EcKeyPair,
    pub_k: EcPublicKey,
    prv_k: EcPrivateKey,
    shared_key: EcShareKey,
    smk: AlignKey128bit,
    role: DhSessionRole,
    timestamp: u64,
}

impl DhEccContext {
    pub fn ecc_handle(&self) -> &EcKeyPair {
        &self.ecc_handle
    }

    pub fn pub_k(&self) -> &EcPublicKey {
        &self.pub_k
    }

    pub fn prv_k(&self) -> &EcPrivateKey {
        &self.prv_k
    }

    pub fn shared_key(&self) -> &EcShareKey {
        &self.shared_key
    }

    pub fn smk(&self) -> &AlignKey128bit {
        &self.smk
    }

    pub fn role(&self) -> &DhSessionRole {
        &self.role
    }

    pub fn timestamp(&self) -> u64 {
        self.timestamp
    }
}

#[derive(Debug)]
pub struct Peer<'a> {
    pub role: DhSessionRole,
    pub_k: EcPublicKey,
    signature: &'a [u8],
}

impl<'a> Peer<'a> {
    /// Returns a new `Peer` object if the authenticity is verified; otherwise, an error will be returned.
    pub fn new(peer_pub_key: &[u8; ECP_COORDINATE_SIZE], signature: &'a [u8]) -> SgxResult<Self> {
        #[cfg(mirai)]
        {
            Ok(Self {
                role: DhSessionRole::default(),
                pub_k: EcPublicKey::default(),
                signature,
            })
        }

        #[cfg(not(mirai))]
        {
            // Convert from a raw byte array into Ecc256PubKey.
            let pub_k_gx = peer_pub_key[..ECP256_KEY_SIZE].to_vec();
            let pub_k_gy = peer_pub_key[ECP256_KEY_SIZE..].to_vec();
            let mut pub_256_k = Ec256PublicKey::default();

            pub_256_k.gx.copy_from_slice(
                pub_k_gx
                    .iter()
                    .copied()
                    .rev()
                    .collect::<alloc::vec::Vec<u8>>()
                    .as_slice(),
            );
            pub_256_k.gy.copy_from_slice(
                pub_k_gy
                    .iter()
                    .copied()
                    .rev()
                    .collect::<alloc::vec::Vec<u8>>()
                    .as_slice(),
            );

            // Construct the certificate.
            let cert = SP_CERT.split("-----").collect::<Vec<&str>>()[2];
            let cert_str = String::from(cert).replace("\n", "");
            let cert_decoded = base64::decode(&cert_str).unwrap();
            let webpki_cert = webpki::EndEntityCert::try_from(cert_decoded.as_slice()).unwrap();

            // Note that we need to manually append "0x04".
            let mut msg = peer_pub_key.to_vec();
            msg.insert(0, 0x04);

            if webpki_cert
                .verify_signature(&webpki::ECDSA_P256_SHA256, &msg, signature)
                .is_err()
            {
                // Signature does not match may due to a forge?
                return Err(SgxStatus::InvalidSignature);
            }

            Ok(Self {
                role: DhSessionRole::default(),
                pub_k: EcPublicKey::from(pub_256_k),
                signature,
            })
        }
    }
}

/// Denotes a Diffie-Hellman session status.
/// * `Closed` => This is either an invalid context or new context.
/// * `InProgress` => Not finished yet.
/// * `Active` => Valid, and a session key can be extracted from this status.
/// * (not sure) `Expired` => The session is valid but expired given the time limit.
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DhStatus {
    Closed,
    InProgress,
    Active,
    // Maybe?
    Expired,
}

impl Default for DhStatus {
    fn default() -> Self {
        DhStatus::Closed
    }
}

/// Defines a full Diffie-Hellman context.
#[derive(Debug)]
pub struct DhSession {
    // A random nonce that marks this DH context.
    session_id: u64,
    session_status: DhStatus,
    session_context: DhEccContext,
}

impl DhSession {
    pub fn session_id(&self) -> u64 {
        self.session_id
    }

    pub fn session_status(&self) -> DhStatus {
        self.session_status
    }

    pub fn mut_session_status(&mut self) -> &mut DhStatus {
        &mut self.session_status
    }

    pub fn session_context(&self) -> &DhEccContext {
        &self.session_context
    }

    pub fn mut_session_context(&mut self) -> &mut DhEccContext {
        &mut self.session_context
    }

    pub fn compute_shared_key(&mut self, peer: &Peer) -> SgxResult<()> {
        // Should first check the status.
        if self.session_status != DhStatus::InProgress {
            return Err(SgxStatus::InvalidState);
        }

        // Check if the public key is derived from this private key.
        #[cfg(not(mirai))]
        if self.session_context.pub_k != self.session_context.prv_k.export_public_key().unwrap() {
            // Corrupted input.
            return Err(SgxStatus::InvalidParameter);
        }

        // Check if this is the reponder.
        if self.session_context.role != DhSessionRole::Responder
            || self.session_context.role == peer.role
        {
            return Err(SgxStatus::InvalidState);
        }

        #[cfg(not(mirai))]
        {
            // Compute the shared_key key.
            self.session_context.shared_key = self.session_context.prv_k.shared_key(&peer.pub_k)?;
            self.session_context.smk = self
                .session_context
                .shared_key
                .derive_key(KDF_MAGIC_STR.as_bytes())?;

            // Set the current timestamp.
            self.session_context.timestamp = unix_time(0)?;
        }

        Ok(())
    }

    /// Returns true if the key is still within its lifetime.
    pub fn is_valid(&self) -> bool {
        let cur_time = unix_time(0).unwrap();
        let key_time = self.session_context.timestamp;

        checked_assume!(cur_time >= key_time);

        let elapsed_time = cur_time - key_time;

        elapsed_time <= DH_KEY_EXPIRATION
    }
}

/// Returns a valid DH session if peer authenticates.
/// The function will first check the validity of the public key signature using ECDSA.
/// If the signature is valid, then it will open an ECC context and generates an ephemeral
/// key pair, completing the generation of session key.
pub fn perform_ecdh(
    peer_pub_key: &[u8; ECP_COORDINATE_SIZE],
    signature: &[u8],
) -> SgxResult<DhSession> {
    // Construct peer from its public key and signature.
    let mut peer = match Peer::new(peer_pub_key, signature) {
        Ok(peer) => peer,
        Err(e) => {
            assume_unreachable!("[-] Public key signature is invalid due to {:?}.", e);

            return Err(e);
        }
    };
    peer.role = DhSessionRole::Initiator;

    verified_log!("[+] Peer authentication passed.");

    // Open the DH session on the enclave side.
    let mut session = match open_dh_session() {
        Ok(session) => session,
        Err(e) => {
            assume_unreachable!("[-] Failed to open the ECDH session due to {:?}.", e);

            return Err(e);
        }
    };

    // Generate the session key.
    if let Err(e) = session.compute_shared_key(&peer) {
        assume_unreachable!("[-] Failed to generate the session key due to {:?}.", e);
        Err(e)
    } else {
        Ok(session)
    }
}

/// Opens an empheral Diffie-Hellman session context.
///
/// Since the enclave will receive a request from the SP, so we must know who should be
/// the intiator. We do not need to return a raw EccContext.
pub fn open_dh_session() -> SgxResult<DhSession> {
    #[cfg(not(mirai))]
    {
        // Generate a random number.
        let mut os_rng = sgx_trts::rand::Rng::new();
        let session_id = os_rng.next_u64();

        // Open the ECC context and sample a key pair.
        let ecc_handle = EcKeyPair::create()?;
        let prv_k = ecc_handle.private_key();
        let pub_k = ecc_handle.public_key();

        Ok(DhSession {
            session_id,
            session_status: DhStatus::InProgress,
            session_context: DhEccContext {
                ecc_handle,
                prv_k,
                pub_k,
                shared_key: EcShareKey::default(),
                smk: AlignKey128bit::default(),
                role: DhSessionRole::Responder,
                // Not valid.
                timestamp: 0u64,
            },
        })
    }

    #[cfg(mirai)]
    Ok(DhSession {
        session_id: 0,
        session_status: DhStatus::InProgress,
        session_context: DhEccContext {
            ecc_handle: EcKeyPair::default(),
            prv_k: EcPrivateKey::default(),
            pub_k: EcPublicKey::default(),
            shared_key: EcShareKey::default(),
            smk: AlignKey128bit::default(),
            role: DhSessionRole::Responder,
            // Not valid.
            timestamp: 0u64,
        },
    })
}
