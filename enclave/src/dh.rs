use alloc::string::String;
use alloc::vec::Vec;

use sgx_crypto::ecc::*;
use sgx_types::{
    error::{SgxResult, SgxStatus},
    types::{AlignKey128bit, DhSessionRole, Ec256PublicKey, ECP256_KEY_SIZE},
};

/// Time for expiration. We currently set it to 600 seconds (5 min).
/// If the key is expired, the both sides are notified and then re-negotiate a new one.
pub const DH_KEY_EXPIRATION: i64 = 600;

/// A magic string that identifies the key.
pub const KDF_MAGIC_STR: &'static str = "PoBF/enclave&session-key";

/// Used to verify the signature of the public key. Hardcoded into the enclave.
/// Can be easily generated by OpenSSL.
/// Command is
/// ```shell
///   $ openssl ecparam -name prime256v1 -genkey > /tmp/ecprivkey.pem \
///   $ openssl ec -in /tmp/ecprivkey.pem -text -noout
///     read EC key
///     using curve name prime256v1 instead of secp256r1
///     Private-Key: (256 bit)
///     [key details]
///     ASN1 OID: prime256v1
///     NIST CURVE: P-256
///   $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt \
///     -in ecprivkey.pem -out ecprivpkcs8.pem # Convert to pkcs#8 format.
/// ```
/// This certificate is self-signed and used only in development environment.
/// It is a must that the SP obtains a Root CA-signed (e.g. DigiCert, GeoTrust) certificate.
pub const SP_CERT: &'static str = "-----BEGIN CERTIFICATE-----
MIICbzCCAhWgAwIBAgIUYoPMHkOlEJHtlnvTIKDV/Ladp5gwCgYIKoZIzj0EAwIw
gYwxCzAJBgNVBAYTAlVTMRAwDgYDVQQIDAdJbmRpYW5hMRQwEgYDVQQHDAtCbG9v
bWluZ3RvbjEbMBkGA1UECgwSSW5kaWFuYSBVbml2ZXJzaXR5MSQwIgYDVQQLDBtM
dWRkeSBTY2hvb2wgb2YgSW5mb3JtYXRpY3MxEjAQBgNVBAMMCTEyNy4wLjAuMTAe
Fw0yMjEwMjEwMjUyMTNaFw0zMjEwMTgwMjUyMTNaMIGMMQswCQYDVQQGEwJVUzEQ
MA4GA1UECAwHSW5kaWFuYTEUMBIGA1UEBwwLQmxvb21pbmd0b24xGzAZBgNVBAoM
EkluZGlhbmEgVW5pdmVyc2l0eTEkMCIGA1UECwwbTHVkZHkgU2Nob29sIG9mIElu
Zm9ybWF0aWNzMRIwEAYDVQQDDAkxMjcuMC4wLjEwWTATBgcqhkjOPQIBBggqhkjO
PQMBBwNCAAQgaU4UnfRFlhxKBDT1AqWENEFR4AV6WpzZ7L6lV7tGTxdcxi1PNNXe
8hQXG6cj8gcCyYhy4DrgvduaWeqTnqZeo1MwUTAdBgNVHQ4EFgQUdF6of7qm511v
tvMfbMWOe1jv7QEwHwYDVR0jBBgwFoAUdF6of7qm511vtvMfbMWOe1jv7QEwDwYD
VR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAgNIADBFAiA+zu0DCqma/pnpgEhx+oAy
yGOxdFLHoZoAyN4ec4W+awIhAJfzb181oFh3G3qQT//VMv3AxwIU5hy0rmoNb9LS
5jem
-----END CERTIFICATE-----";

/// A wrapper class for an empheral Diffie-Hellman session with the client.
/// Owned by the receiver. The key is define on the curve NIST P-256 a.k.a.
/// secp256r1, prime256v1.
#[derive(Debug)]
pub struct DhEccContext {
    ecc_handle: EcKeyPair,
    pub_k: EcPublicKey,
    prv_k: EcPrivateKey,
    shared_key: EcShareKey,
    smk: AlignKey128bit,
    role: DhSessionRole,
}

impl DhEccContext {
    pub fn ecc_handle(&self) -> &EcKeyPair {
        &self.ecc_handle
    }

    pub fn pub_k(&self) -> &EcPublicKey {
        &self.pub_k
    }

    pub fn prv_k(&self) -> &EcPrivateKey {
        &self.prv_k
    }

    pub fn shared_key(&self) -> &EcShareKey {
        &self.shared_key
    }

    pub fn smk(&self) -> &AlignKey128bit {
        &self.smk
    }
}

#[derive(Debug)]
pub struct Peer<'a> {
    pub role: DhSessionRole,
    pub_k: EcPublicKey,
    signature: &'a [u8],
}

impl<'a> Peer<'a> {
    /// Returns a new `Peer` object if the authenticity is verified; otherwise, an error will be returned.
    pub fn new(peer_pub_key: &[u8; 64], signature: &'a [u8]) -> SgxResult<Self> {
        // Convert from a raw byte array into Ecc256PubKey.
        let pub_k_gx = peer_pub_key[..ECP256_KEY_SIZE].to_vec();
        let pub_k_gy = peer_pub_key[ECP256_KEY_SIZE..].to_vec();
        let mut pub_256_k = Ec256PublicKey::default();

        pub_256_k.gx.copy_from_slice(
            pub_k_gx
                .iter()
                .copied()
                .rev()
                .collect::<alloc::vec::Vec<u8>>()
                .as_slice(),
        );
        pub_256_k.gy.copy_from_slice(
            pub_k_gy
                .iter()
                .copied()
                .rev()
                .collect::<alloc::vec::Vec<u8>>()
                .as_slice(),
        );

        // Construct the certificate.
        let cert = SP_CERT.split("-----").collect::<Vec<&str>>()[2];
        let cert_str = String::from(cert).replace("\n", "");
        let cert_decoded = base64::decode(&cert_str).unwrap();
        let webpki_cert = webpki::EndEntityCert::try_from(cert_decoded.as_slice()).unwrap();

        // Note that we need to manually append "0x04".
        let mut msg = peer_pub_key.to_vec();
        msg.insert(0, 0x04);

        if let Err(e) = webpki_cert.verify_signature(&webpki::ECDSA_P256_SHA256, &msg, signature) {
            // Signature does not match may due to a forge?
            return Err(SgxStatus::InvalidSignature);
        }

        Ok(Self {
            role: DhSessionRole::default(),
            pub_k: EcPublicKey::from(pub_256_k),
            signature,
        })
    }
}

/// Denotes a Diffie-Hellman session status.
/// * `Closed` => This is either an invalid context or new context.
/// * `InProgress` => Not finished yet.
/// * `Active` => Valid, and a session key can be extracted from this status.
/// * (not sure) `Expired` => The session is valid but expired given the time limit.
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DhStatus {
    Closed,
    InProgress,
    Active,
    // Maybe?
    Expired,
}

impl Default for DhStatus {
    fn default() -> Self {
        DhStatus::Closed
    }
}

/// Defines a full Diffie-Hellman context.
#[derive(Debug)]
pub struct DhSession {
    // A random nonce that marks this DH context.
    session_id: u64,
    session_status: DhStatus,
    session_context: DhEccContext,
}

impl DhSession {
    pub fn session_id(&self) -> u64 {
        self.session_id
    }

    pub fn session_status(&self) -> DhStatus {
        self.session_status
    }

    pub fn mut_session_status(&mut self) -> &mut DhStatus {
        &mut self.session_status
    }

    pub fn session_context(&self) -> &DhEccContext {
        &self.session_context
    }

    pub fn mut_session_contexy(&mut self) -> &mut DhEccContext {
        &mut self.session_context
    }

    pub fn compute_shared_key(&mut self, peer: &Peer) -> SgxResult<()> {
        // Should first check the status.
        if self.session_status != DhStatus::InProgress {
            return Err(SgxStatus::InvalidState);
        }

        // Check if the public key is derived from this private key.
        if self.session_context.pub_k != self.session_context.prv_k.export_public_key().unwrap() {
            // Corrupted input.
            return Err(SgxStatus::InvalidParameter);
        }

        // Check if this is the reponder.
        if self.session_context.role != DhSessionRole::Responder
            || self.session_context.role == peer.role
        {
            return Err(SgxStatus::InvalidState);
        }

        // Compute the shared_key key.
        self.session_context.shared_key = self.session_context.prv_k.shared_key(&peer.pub_k)?;
        self.session_context.smk = self
            .session_context
            .shared_key
            .derive_key(KDF_MAGIC_STR.as_bytes())?;

        Ok(())
    }
}

/// Opens an empheral Diffie-Hellman session context.
///
/// Since the enclave will receive a request from the SP, so we must know who should be
/// the intiator. We do not need to return a raw EccContext.
pub fn open_dh_session() -> SgxResult<DhSession> {
    // Generate a random number.
    let mut os_rng = sgx_trts::rand::Rng::new();
    let session_id = os_rng.next_u64();

    // Open the ECC context and sample a key pair.
    let ecc_handle = EcKeyPair::create()?;
    let prv_k = ecc_handle.private_key();
    let pub_k = ecc_handle.public_key();

    Ok(DhSession {
        session_id,
        session_status: DhStatus::InProgress,
        session_context: DhEccContext {
            ecc_handle,
            prv_k,
            pub_k,
            shared_key: EcShareKey::default(),
            smk: AlignKey128bit::default(),
            role: DhSessionRole::Responder,
        },
    })
}
